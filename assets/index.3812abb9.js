(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{15:function(e,t){class n extends Error{constructor(e){super(e),this.location=[]}add_location(e){this.location.unshift(e)}toString(){return this.location.length?`${this.name} at template${this.location.join("")}: ${this.message}`:`${this.name}: ${this.message}`}}class r extends n{constructor(e){super(e),this.message=e,this.name="BaseError"}}e.exports={JSONTemplateError:n,SyntaxError:class extends n{constructor(e){super(e),this.message=e,this.name="SyntaxError"}},InterpreterError:class extends r{constructor(e){super(e),this.name="InterpreterError"}},TemplateError:class extends r{constructor(e){super(e),this.name="TemplateError"}},BuiltinError:class extends r{constructor(e){super(e),this.name="BuiltinError"}}}},183:function(e,t,n){const{UnaryOp:r,BinOp:a,Primitive:s,ContextValue:o,FunctionCall:i,ValueAccess:l,List:c,Object:u}=n(184),{SyntaxError:h}=n(15);let p=(e,t)=>(t.sort(),new h(`Found ${e.value}, expected ${t.join(", ")}`,e));let m=e=>e.slice(1,-1);t.Parser=class{constructor(e,t,n=0){this._source=t,this._tokenizer=e,this.current_token=this._tokenizer.next(this._source,n),this.unaryOpTokens=["-","+","!"],this.primitivesTokens=["number","null","true","false","string"],this.operations=[["||"],["&&"],["in"],["==","!="],["<",">","<=",">="],["+","-"],["*","/"],["**"]],this.expectedTokens=["!","(","+","-","[","false","identifier","null","number","string","true","{"]}takeToken(...e){if(null==this.current_token)throw new h("Unexpected end of input");if(e.length>0&&-1===e.indexOf(this.current_token.kind))throw p(this.current_token,e);try{this.current_token=this._tokenizer.next(this._source,this.current_token.end)}catch(e){throw e}}parse(e=0){let t;if(e==this.operations.length-1){t=this.parsePropertyAccessOrFunc();let n=this.current_token;for(;null!=n&&-1!==this.operations[e].indexOf(n.kind);n=this.current_token)this.takeToken(n.kind),t=new a(n,this.parse(e),t)}else{t=this.parse(e+1);let n=this.current_token;for(;null!=n&&-1!==this.operations[e].indexOf(n.kind);n=this.current_token)this.takeToken(n.kind),t=new a(n,t,this.parse(e+1))}return t}parsePropertyAccessOrFunc(){let e,t=this.parseUnit(),n=["[","(","."];for(let r=this.current_token;null!=r&&-1!==n.indexOf(r.kind);r=this.current_token)"["==r.kind?t=this.parseAccessWithBrackets(t):"."==r.kind?(r=this.current_token,this.takeToken("."),e=new s(this.current_token),this.takeToken("identifier"),t=new a(r,t,e)):"("==r.kind&&(t=this.parseFunctionCall(t));return t}parseUnit(){let e,t=this.current_token,n=-1!==this.unaryOpTokens.indexOf(t.kind),a=-1!==this.primitivesTokens.indexOf(t.kind);if(null==this.current_token)throw new h("Unexpected end of input");if(n)this.takeToken(t.kind),e=new r(t,this.parseUnit());else if(a)this.takeToken(t.kind),e=new s(t);else if("identifier"==t.kind)this.takeToken(t.kind),e=new o(t);else if("("==t.kind){if(this.takeToken("("),e=this.parse(),null==e)throw p(this.current_token,this.expectedTokens);this.takeToken(")")}else"["==t.kind?e=this.parseList():"{"==t.kind&&(e=this.parseObject());return e}parseFunctionCall(e){let t,n=this.current_token,r=[];if(this.takeToken("("),")"!=this.current_token.kind)for(t=this.parse(),r.push(t);null!=this.current_token&&","==this.current_token.kind;){if(null==r[r.length-1])throw p(this.current_token,this.expectedTokens);this.takeToken(","),t=this.parse(),r.push(t)}return this.takeToken(")"),t=new i(n,e,r),t}parseList(){let e,t=[],n=this.current_token;if(this.takeToken("["),"]"!=this.current_token.kind)for(e=this.parse(),t.push(e);","==this.current_token.kind;){if(null==t[t.length-1])throw p(this.current_token,this.expectedTokens);this.takeToken(","),e=this.parse(),t.push(e)}return this.takeToken("]"),e=new c(n,t),e}parseAccessWithBrackets(e){let t=null,n=null,r=this.current_token,a=!1;if(this.takeToken("["),"]"==this.current_token.kind)throw p(this.current_token,this.expectedTokens);if(":"!=this.current_token.kind&&(t=this.parse()),":"==this.current_token.kind&&(a=!0,this.takeToken(":")),"]"!=this.current_token.kind&&(n=this.parse()),a&&null==n&&"]"!=this.current_token.kind)throw p(this.current_token,this.expectedTokens);return this.takeToken("]"),e=new l(r,e,a,t,n)}parseObject(){let e,t,n,r={},a=this.current_token;this.takeToken("{");let s=this.current_token;for(;null!=s&&("string"==s.kind||"identifier"==s.kind);){if(t=s.value,"string"==s.kind&&(t=m(t)),this.takeToken(s.kind),this.takeToken(":"),n=this.parse(),null==n)throw p(this.current_token,this.expectedTokens);if(r[t]=n,null!=this.current_token&&"}"==this.current_token.kind)break;this.takeToken(","),s=this.current_token}return this.takeToken("}"),e=new u(a,r),e}}},184:function(e,t){class n{constructor(e){this.token=e,this.constructorName="ASTNode"}}let r=n;t.ASTNode=n,t.BinOp=class extends n{constructor(e,t,n){super(e),this.constructorName="BinOp",this.left=t,this.right=n}},t.UnaryOp=class extends n{constructor(e,t){super(e),this.constructorName="UnaryOp",this.expr=t}},t.Primitive=r,t.FunctionCall=class extends n{constructor(e,t,n){super(e),this.constructorName="FunctionCall",this.name=t,this.args=n}},t.ContextValue=class{constructor(e){this.token=e,this.constructorName="ContextValue"}},t.ValueAccess=class extends n{constructor(e,t,n,r,a){super(e),this.constructorName="ValueAccess",this.isInterval=n,this.arr=t,this.left=r,this.right=a}},t.List=class extends n{constructor(e,t){super(e),this.constructorName="List",this.list=t}},t.Object=class extends n{constructor(e,t){super(e),this.constructorName="Object",this.obj=t}}},185:function(e,t,n){var{SyntaxError:r}=n(15);let a=e=>(e=>{if("string"!=typeof e)return!1;try{new RegExp(`^${e}$`)}catch(e){return!1}return!0})(e)&&1===new RegExp(`^(?:|${e})$`).exec("").length,s=(e,t=0)=>{let n=e.length;for(let r=t;r<n;r++)if(void 0!==e[r])return r;return-1};const o=e=>{if(!e)throw new Error("Token configuration is invalid")};e.exports=class{constructor(e={}){e=Object.assign({},{ignore:null,patterns:{},tokens:[]},e),o(null===e.ignore||a(e.ignore)),o(e.patterns instanceof Object);for(let t of Object.keys(e.patterns))o(a(e.patterns[t]));o(e.tokens instanceof Array),e.tokens.forEach(e=>o("string"==typeof e)),this._tokens=e.tokens,this._hasIgnore=e.ignore?1:0,this._regex=new RegExp("^(?:"+[this._hasIgnore?`(${e.ignore})`:null,...this._tokens.map(t=>{return`(${e.patterns[t]||(n=t,n.replace(/[-\/\\^$*+?.()|[\]{}]/g,"\\$&"))})`;var n})].filter(e=>null!==e).join("|")+")")}next(e,t=0){let n,a;do{if(n=this._regex.exec(e.slice(t)),null===n){if(""!==e.slice(t))throw new r(`Unexpected input for '${e}' at '${e.slice(t)}'`,{start:t,end:e.length});return null}a=s(n,1),t+=n[0].length}while(this._hasIgnore&&1===a);return{kind:this._tokens[a-1-this._hasIgnore],value:n[a],start:t-n[0].length,end:t}}tokenize(e,t=0){let n={end:t},r=[];for(;n=this.next(e,n.end);)r.push(n);return r}}},186:function(e,t,n){const{isFunction:r,isObject:a,isString:s,isArray:o,isNumber:i,isInteger:l,isTruthy:c}=n(28),{InterpreterError:u}=n(15);let h=(e,t)=>new u(`${e} expects ${t}`);let p=(e,t)=>{if(o(e)&&o(t)&&e.length===t.length){for(let n=0;n<e.length;n++)if(!p(e[n],t[n]))return!1;return!0}if(r(e))return e===t;if(a(e)&&a(t)){let n=Object.keys(e).sort();if(!p(n,Object.keys(t).sort()))return!1;for(let r of n)if(!p(e[r],t[r]))return!1;return!0}return e===t},m=(e,t,n)=>{if("+"===e&&!(i(t)&&i(n)||s(t)&&s(n)))throw h("infix: +","numbers/strings + numbers/strings");if(["-","*","/","**"].some(t=>t===e)&&(!i(t)||!i(n)))throw h("infix: "+e,`number ${e} number`)},d=(e,t,n)=>{if("=="===e||"!="===e)return null;if(!([">=","<=","<",">"].some(t=>t===e)&&(i(t)&&i(n)||s(t)&&s(n))))throw h("infix: "+e,`numbers/strings ${e} numbers/strings`)};t.Interpreter=class{constructor(e){this.context=e}visit(e){return this["visit_"+e.constructorName](e)}visit_ASTNode(e){let t;switch(e.token.kind){case"number":return+e.token.value;case"null":return null;case"string":return t=e.token.value.slice(1,-1),t;case"true":return!0;case"false":return!1;case"identifier":return e.token.value}}visit_UnaryOp(e){let t=this.visit(e.expr);switch(e.token.kind){case"+":if(!i(t))throw h("unary +","number");return+t;case"-":if(!i(t))throw h("unary -","number");return-t;case"!":return!c(t)}}visit_BinOp(e){let t,n=this.visit(e.left);switch(e.token.kind){case"||":return c(n)||c(this.visit(e.right));case"&&":return c(n)&&c(this.visit(e.right));default:t=this.visit(e.right)}switch(e.token.kind){case"+":return m("+",n,t),n+t;case"-":return m("-",n,t),n-t;case"/":return m("/",n,t),n/t;case"*":return m("*",n,t),n*t;case">":return d(">",n,t),n>t;case"<":return d("<",n,t),n<t;case">=":return d(">=",n,t),n>=t;case"<=":return d("<=",n,t),n<=t;case"!=":return d("!=",n,t),!p(n,t);case"==":return d("==",n,t),p(n,t);case"**":return m("**",n,t),Math.pow(t,n);case".":if(a(n)){if(n.hasOwnProperty(t))return n[t];throw new u(`object has no property "${t}"`)}throw h("infix: .","objects");case"in":if(a(t)){if(!s(n))throw h("Infix: in-object","string on left side");t=Object.keys(t)}else{if(s(t)){if(!s(n))throw h("Infix: in-string","string on left side");return-1!==t.indexOf(n)}if(!o(t))throw h("Infix: in","Array, string, or object on right side")}return t.some(e=>p(n,e))}}visit_List(e){let t=[];return void 0!==e.list[0]&&e.list.forEach((function(e){t.push(this.visit(e))}),this),t}visit_ValueAccess(e){let t=this.visit(e.arr),n=0,r=null;if(e.left&&(n=this.visit(e.left)),e.right&&(r=this.visit(e.right)),n<0&&(n=t.length+n),o(t)||s(t)){if(e.isInterval){if(r=null===r?t.length:r,r<0&&(r=t.length+r,r<0&&(r=0)),n>r&&(n=r),!l(n)||!l(r))throw new u("cannot perform interval access with non-integers");return t.slice(n,r)}if(!l(n))throw new u("should only use integers to access arrays or strings");if(n>=t.length)throw new u("index out of bounds");return t[n]}if(!a(t))throw h('infix: "[..]"',"object, array, or string");if(!s(n))throw new u("object keys must be strings");return t.hasOwnProperty(n)?t[n]:null}visit_ContextValue(e){if(this.context.hasOwnProperty(e.token.value)){return this.context[e.token.value]}throw new u("unknown context value "+e.token.value)}visit_FunctionCall(e){let t=[],n=this.visit(e.name);if(r(n))return e.args.forEach((function(e){t.push(this.visit(e))}),this),n.hasOwnProperty("jsone_builtin")&&t.unshift(this.context),n.apply(null,t);throw new u(n+" is not callable")}visit_Object(e){let t={};for(let n in e.obj)t[n]=this.visit(e.obj[n]);return t}interpret(e){return this.visit(e)}}},188:function(e,t,n){var{BuiltinError:r}=n(15),a=n(45),{isString:s,isNumber:o,isBool:i,isArray:l,isObject:c,isJSON:u,isNull:h,isFunction:p}=n(28);let m={string:s,number:o,boolean:i,array:l,object:c,json:u,null:h,function:p},d=e=>new r("invalid arguments to "+e);e.exports=e=>{let t={},n=(e,t,{argumentTests:n=[],minArgs:r=!1,variadic:a=null,needsContext:s=!1,invoke:o})=>(t[e]=(...t)=>{let i=t.shift();if(!a&&t.length<n.length)throw d("builtin: "+e,t.toString());if(r&&t.length<r)throw d(`builtin: ${e}: expected at least ${r} arguments`);return a&&(n=t.map(()=>a)),t.forEach((t,r)=>{if(!n[r].split("|").some(e=>m[e](t)))throw d("builtin: "+e,n[r])}),s?o(i,...t):o(...t)},t[e].jsone_builtin=!0,t[e]);return["max","min"].forEach(e=>{if(null==Math[e])throw new Error(e+" in Math undefined");n(e,t,{minArgs:1,variadic:"number",invoke:(...t)=>Math[e](...t)})}),["sqrt","ceil","floor","abs"].forEach(e=>{if(null==Math[e])throw new Error(e+" in Math undefined");n(e,t,{argumentTests:["number"],invoke:t=>Math[e](t)})}),n("lowercase",t,{argumentTests:["string"],invoke:e=>e.toLowerCase()}),n("uppercase",t,{argumentTests:["string"],invoke:e=>e.toUpperCase()}),n("str",t,{argumentTests:["string|number|boolean|null"],invoke:e=>null===e?"null":e.toString()}),n("number",t,{argumentTests:["string"],invoke:Number}),n("len",t,{argumentTests:["string|array"],invoke:e=>Array.from(e).length}),n("strip",t,{argumentTests:["string"],invoke:e=>e.trim()}),n("rstrip",t,{argumentTests:["string"],invoke:e=>e.replace(/\s+$/,"")}),n("lstrip",t,{argumentTests:["string"],invoke:e=>e.replace(/^\s+/,"")}),n("split",t,{minArgs:1,variadic:"string|number",invoke:(e,t)=>e.split(t)}),n("join",t,{argumentTests:["array","string|number"],invoke:(e,t)=>e.join(t)}),n("fromNow",t,{variadic:"string",minArgs:1,needsContext:!0,invoke:(e,t,n)=>a(t,n||e.now)}),n("typeof",t,{argumentTests:["string|number|boolean|array|object|null|function"],invoke:e=>{for(let t of["string","number","boolean","array","object","function"])if(m[t](e))return t;if(m.null(e))return"null";throw d("builtin: typeof")}}),n("defined",t,{argumentTests:["string"],needsContext:!0,invoke:(e,t)=>e.hasOwnProperty(t)}),Object.assign({},t,e)}},190:function(e,t,n){"use strict";n.r(t);var r=n(0),a=n.n(r),s=n(29),o=n(4),i=n(48),l=n(49),c=n(50),u=n.n(c);class h{constructor(e){Object.assign(this,e),this.children=[]}child(e){return Object(l.find)(this.children,{title:e})}get anchor(){return this.title.replace(/[^a-zA-Z0-9]+/g,"-").toLowerCase()}}var p=n(31),m=n.n(p),d=n(32),f=n.n(d);const g=/template:([^]*)\ncontext:([^]*)\nresult:/m;var y=({value:e})=>{const t=g.exec(e);return a.a.createElement("div",{className:"demo-block"},a.a.createElement("pre",null,a.a.createElement("code",null,e)),t&&a.a.createElement(o.a,{onClick:()=>{return e=t[1],n=t[2],void(window.location.hash=`#Playground/${encodeURIComponent(f()(n).trim())}&${encodeURIComponent(f()(e).trim())}`);var e,n}},"Play in Playground"))};const b=({showDemo:e,section:t})=>{const n=e?{code:y}:{};return a.a.createElement("div",{id:t.anchor,className:"demo"},t.heading&&a.a.createElement(m.a,{source:t.heading}),t.body&&a.a.createElement(m.a,{source:t.body,renderers:n}),(t.children||[]).map(t=>a.a.createElement(b,{showDemo:e,section:t,key:t.anchor})))};var v=b;const w=({section:e,title:t,tab:n})=>a.a.createElement("li",null,a.a.createElement(o.c,{href:`#${n}/${e.anchor}`},t),e.children.length>0&&a.a.createElement("ul",null,e.children.map(e=>a.a.createElement(w,{key:e.anchor,tab:n,title:e.title,section:e}))));w.defaultProps={section:{children:[],anchor:""}};var x=w,$=n(12),k=n.n($),j=n(16),T=n.n(j),O=n(51),_=n.n(O),E=n(52),N=n.n(E);const S={mode:"yaml",lint:!0,theme:"elegant",indentWithTabs:!1,tabSize:2,gutters:["CodeMirror-lint-markers"]};class A extends a.a.Component{constructor(...e){var t,n,r;super(...e),r={template:"{}",context:"{}"},(n="state")in(t=this)?Object.defineProperty(t,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[n]=r}componentWillMount(){window.addEventListener("hashchange",()=>this.hashChanged()),this.hashChanged()}hashChanged(){if(window.location.hash){const e=/#Playground\/(.*)&(.*)/.exec(window.location.hash);if(e){this.setState({context:decodeURIComponent(e[1]),template:decodeURIComponent(e[2])}),history.replaceState({},"Playground","#Playground");document.getElementById("Playground/").scrollIntoView()}}}updateContext(e){try{k.a.safeLoad(e),this.setState({context:e})}catch(e){if("YAMLException"!==e.name)throw e}}updateTemplate(e){try{k.a.safeLoad(e),this.setState({template:e})}catch(e){if("YAMLException"!==e.name)throw e}}render(){const{context:e,template:t,copied:n}=this.state,r=`${document.location.origin}${document.location.pathname}#Playground/${encodeURIComponent(e)}&${encodeURIComponent(t)}`;let s,i;try{s=k.a.safeDump(N()(k.a.safeLoad(t)||null,k.a.safeLoad(e)||{}))}catch(e){i=e}return a.a.createElement("div",{id:"Playground/"},a.a.createElement(o.b,{f:1},"Playground"),a.a.createElement("div",{className:"codeblocks"},a.a.createElement("div",null,a.a.createElement(o.b,{f:2},"Template"),a.a.createElement(T.a,{value:t,onChange:e=>this.updateTemplate(e),options:S})),a.a.createElement("div",null,a.a.createElement(o.b,{f:2},"Context"),a.a.createElement(T.a,{value:e,onChange:e=>this.updateContext(e),options:S})),a.a.createElement("div",null,a.a.createElement(o.b,{f:2},"Results"),s?a.a.createElement(T.a,{value:s,options:{...S,readOnly:"nocursor",gutters:[]}}):a.a.createElement(T.a,{value:"Error:\n"+i.toString(),options:{...S,mode:"null",readOnly:"nocursor",gutters:[],css:'background-color: "tomato"'}}))),a.a.createElement("div",{className:"notes"},a.a.createElement(_.a,{text:r,onCopy:()=>this.setState({copied:!0})},a.a.createElement("span",{className:"clicky"},"copy link to this example")),n&&a.a.createElement("span",null,"copied to clipboard!")))}}const z=function(e){let t=[new h];return u.a.parse(e).sections.forEach(e=>{const n=new h(e);n.level>0&&t[n.level-1].children.push(n),t=t.slice(0,n.level).concat([n])}),t[0]}("* [Full documentation](https://json-e.js.org)\n\n# JSON-e\n\nJSON-e is a data-structure parameterization system for embedding context in\nJSON objects.\n\nThe central idea is to treat a data structure as a \"template\" and transform it,\nusing another data structure as context, to produce an output data structure.\n\nThere are countless libraries to do this with strings, such as\n[mustache](https://mustache.github.io/). What makes JSON-e unique is that it\noperates on data structures, not on their textual representation. This allows\ninput to be written in a number of formats (JSON, YAML, etc.) or even generated\ndynamically. It also means that the output cannot be \"invalid\", even when\nincluding large chunks of contextual data.\n\nJSON-e is also designed to be safe for use on untrusted data. It never uses\n`eval` or any other function that might result in arbitrary code execution. It\nalso disallows unbounded iteration, so any JSON-e rendering operation will\nfinish in finite time.\n\n## Changes\n\nSee\n[CHANGELOG.rst](https://github.com/taskcluster/json-e/blob/main/CHANGELOG.rst)\nfor the changes in each version of this library.\n\n# Interface\n\n## JavaScript\n\nThe JS module is installed with either of\n\n```shell\nnpm install --save json-e\nyarn add json-e\n```\n\nThe module exposes following interface:\n\n```javascript\nimport jsone from 'json-e';\n\nvar template = {a: {$eval: \"foo.bar\"}};\nvar context = {foo: {bar: \"zoo\"}};\nconsole.log(jsone(template, context));\n// -> { a: 'zoo' }\n```\n\nNote that the context can contain functions, and those functions can be called\nfrom the template:\n\n```javascript\nvar template = {$eval: \"foo(1)\"};\nvar context = {\"foo\": function(x) { return x + 2; }};\nconsole.log(jsone(template, context));  // -> 3\n```\n\n*NOTE*: Context functions are called synchronously. Any complex asynchronous\noperations should be handled before rendering the template.\n\n*NOTE*: If the template is untrusted, it can pass arbitrary data to functions\nin the context, which must guard against such behavior.\n\n### Browser\n\nJSON-e is distributed as a CommonJS package is not designed to be included\ndirectly in a browser with `<script>`. Instead, it must be incorporated using a\ntool that understands CommonJS such as Webpack.  See\n[Neutrino](https://neutrino.js.org/) for an easy, configuration-free way to\nbuild such applications.\n\n## TypeScript\n\nThe JS module is installed with either of\n\n```shell\nnpm install --save json-e\nyarn add json-e\n```\n\nNote: Type definitions are included with this package, so there's no need of seperate\n`@types/..` installation.\n\nAs 'json-e' is a CommonJS module, the package must be imported like this [(more..)](https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require) for type definitions to work properly:\n\n```typescript\nimport jsone = require('json-e');\n\nvar template = {a: {$eval: \"foo.bar\"}};\nvar context = {foo: {bar: \"zoo\"}};\nconsole.log(jsone(template, context));\n// -> { a: 'zoo' }\n```\n\n## Python\n\nThe Python distribution is installed with\n\n```shell\npip install json-e\n```\n\nThe distribution exposes a `render` function:\n\n```python\nimport jsone\n\ntemplate = {\"a\": {\"$eval\": \"foo.bar\"}}\ncontext = {\"foo\": {\"bar\": \"zoo\"}}\nprint(jsone.render(template, context))  # -> {\"a\": \"zoo\"}\n```\n\nand also allows custom functions in the context:\n\n```python\ntemplate = {\"$eval\": \"foo(1)\"}\ncontext = {\"foo\": lambda x: x + 2}\nprint(jsone.render(template, context))  # -> 3\n```\n\n## Go (golang)\n\nThe [golang package for json-e](https://godoc.org/github.com/taskcluster/json-e) exposes a `Render` function:\n\n```golang\nimport (\n  \"fmt\"\n  \"github.com/taskcluster/json-e\"\n)\n\n// Template must be given using types:\n//   map[string]interface{}, []interface{}, float64, string, bool, nil\n// The same types that json.Unmarshal() will create when targeting an interface{}\ntemplate := map[string]interface{}{\n  \"result\": map[string]interface{}{\n    \"$eval\": \"f() + 5\",\n  },\n}\n// Context can be JSON types just like template, but may also contain functions\n// these can JSON types as arguments, and return a value and optionally an error.\ncontext := map[string]interface{}{\n  \"f\": func() int { return 37 },\n}\n\nfunc main() {\n  value, err := jsone.Render(template, context)\n  fmt.Printf(\"%#v\\n\", value)\n}\n```\n\n## Third-Party Integrations\n\n### rjsone\n\nYou can use the 3rd party package [rjsone](https://wryun.github.io/rjsone/) to template\nJSON-e from the command line, passing templates/contexts as files or arguments and using\nstdout for the result.\n\n### Bazel\n\nYou can use 3rd party [Bazel rule](https://github.com/atlassian/bazel-tools/tree/master/rjsone) to invoke\nrjsone (see above) from Bazel build files.\n\n### Terraform\n\nThe [jsone Terraform provider](https://github.com/taskcluster/terraform-provider-jsone) allows use of JSON-e for templating objects within Terraform.\n\n# Language Reference\n\nThe examples here are given in YAML for ease of reading.  Of course, the\nrendering operation takes place on the parsed data, so the input format is\nirrelevant to its operation.\n\n## Simple Operations\n\nAll JSON-e directives involve the `$` character, so a template without any directives is\nrendered unchanged:\n\n```yaml\ntemplate: {key: [1,2,{key2: 'val', key3: 1}, true], f: false}\ncontext:  {}\nresult:   {key: [1,2,{key2: 'val', key3: 1}, true], f: false}\n```\n\n## String Interpolation\n\nThe simplest form of substitution occurs within strings, using `${..}`:\n\n```yaml\ntemplate: {message: 'hello ${key}', 'k=${num}': true}\ncontext:  {key: 'world', num: 1}\nresult:   {message: 'hello world', 'k=1': true}\n```\n\nThe bit inside the `${..}` is an expression, and must evaluate to something\nthat interpolates obviously into a string (so, a string, number, boolean,).\nIf it is null, then the expression interpolates into an empty string.\nThe expression syntax is described in more detail below.\n\nValues interpolate as their JSON literal values:\n\n```yaml\ntemplate: [\"number: ${num}\", \"booleans: ${t} ${f}\", \"null: ${nil}\"]\ncontext: {num: 3, t: true, f: false, nil: null}\nresult: [\"number: 3\", \"booleans: true false\", \"null: \"]\n```\n\nNote that object keys can be interpolated, too:\n\n```yaml\ntemplate: {\"tc_${name}\": \"${value}\"}\ncontext: {name: 'foo', value: 'bar'}\nresult: {\"tc_foo\": \"bar\"}\n```\n\nThe string `${` can be escaped as `$${`.\n\n## Operators\n\nJSON-e defines a bunch of operators. Each is represented as an object with a\nproperty beginning with `$`. This object can be buried deeply within the\ntemplate. Some operators take additional arguments as properties of the same\nobject.\n\n### `$eval`\n\nThe `$eval` operator evaluates the given expression and is replaced with the\nresult of that evaluation. Unlike with string interpolation, the result need\nnot be a string, but can be an arbitrary data structure.\n\n```yaml\ntemplate: {config: {$eval: 'settings.staging'}}\ncontext:\n  settings:\n    staging:\n      transactionBackend: mock\n    production:\n      transactionBackend: customerdb\nresult:   {config: {transactionBackend: 'mock'}}\n```\n\nThe expression syntax is described in more detail below.\n\nNote that `$eval`'s value must be a string. \"Metaprogramming\" by providing a\ncalculated value to eval is not allowed.  For example, `{$eval: {$eval:\n\"${var1} + ${var2}\"}}` is not valid JSON-e.\n\n### `$json`\n\nThe `$json` operator formats the given value as JSON with sorted keys. It does\nnot evaluate the value (use `$eval` for that). While this can be useful in some\ncases, it is an unusual case to include a JSON string in a larger data\nstructure.\n\n```yaml\ntemplate: {$json: [a, b, {$eval: 'a+b'}, 4]}\ncontext:  {a: 1, b: 2}\nresult:   '[\"a\", \"b\", 3, 4]'\n```\n\n### `$if` - `then` - `else`\n\nThe `$if` operator supports conditionals. It evaluates the given value, and\nreplaces itself with the `then` or `else` properties. If either property is\nomitted, then the expression is omitted from the parent object.\n\n```yaml\ntemplate: {key: {$if: 'cond', then: 1}, k2: 3}\ncontext:  {cond: true}\nresult:   {key: 1, k2: 3}\n```\n\n```yaml\ntemplate: {$if: 'x > 5', then: 1, else: -1}\ncontext:  {x: 10}\nresult:   1\n```\n\n```yaml\ntemplate: [1, {$if: 'cond', else: 2}, 3]\ncontext: {cond: false}\nresult: [1,2,3]\n```\n\n```yaml\ntemplate: {key: {$if: 'cond', then: 2}, other: 3}\ncontext: {cond: false}\nresult: {other: 3}\n```\n\n### `$flatten`\n\nThe `$flatten` operator flattens an array of arrays into one array.\n\n```yaml\ntemplate: {$flatten: [[1, 2], [3, 4], [5]]}\ncontext:  {}\nresult:   [1, 2, 3, 4, 5]\n```\n\n### `$flattenDeep`\n\nThe `$flattenDeep` operator deeply flattens an array of arrays into one array.\n\n```yaml\ntemplate: {$flattenDeep: [[1, [2, [3]]]]}\ncontext:  {}\nresult:   [1, 2, 3]\n```\n\n### `$fromNow`\n\nThe `$fromNow` operator is a shorthand for the built-in function `fromNow`. It\ncreates a JSON (ISO 8601) datestamp for a time relative to the current time\n(see the `now` builtin, below) or, if `from` is given, relative to that time.\nThe offset is specified by a sequence of number/unit pairs in a string. For\nexample:\n\n```yaml\ntemplate: {$fromNow: '2 days 1 hour'}\ncontext:  {}\nresult:   '2017-01-19T16:27:20.974Z'\n```\n\n```yaml\ntemplate: {$fromNow: '1 hour', from: '2017-01-19T16:27:20.974Z'}\ncontext:  {}\nresult:   '2017-01-19T17:27:20.974Z'\n```\n\nThe available units are `day`, `hour`, `minute`, and `second`, for all of which a plural\nis also accepted.\n\n### `$let`\n\nThe `$let` operator evaluates an expression using a context amended with the\ngiven values. It is analogous to the Haskell `where` clause.\n\n```yaml\ntemplate: {$let: {ts: 100, foo: 200},\n           in: [{$eval: \"ts+foo\"}, {$eval: \"ts-foo\"}, {$eval: \"ts*foo\"}]}\ncontext: {}\nresult: [300, -100, 20000]\n```\n\nThe `$let` operator here added the `ts` and `foo` variables to the scope of\nthe context and accordingly evaluated the `in` clause using those variables\nto return the correct result.\n\nAn expression like `{$let: {$eval: \"extraVariables\"}, in : ..}` is supported. As long as\nthe value of `$let` evaluates to an object with valid key(s), the *values* of which are\nevaluated.\n\n```yaml\ntemplate: {$let: {$if: something == 3, then: {a: 10, b: 10}, else: {a: 20, b: 10}},\n          in: {$eval: 'a + b'}}\ncontext:  {'something': 3}\nresult:   20\n```\n\n```yaml\ntemplate: {$let: {\"b\": {$eval: \"a + 10\"}},\n          in: {$eval: \"a + b\"}}\ncontext:  {a: 5}\nresult:   20\n```\n\n```yaml\ntemplate: {$let: {\"first_${name}\": 1, \"second_${name}\": 2},\n          in: {$eval: \"first_prize + second_prize\"}}\ncontext:  {name: \"prize\"}\nresult:   3\n```\n\n### `$map`\n\nThe `$map` operator evaluates an expression for each value of the given array or object,\nconstructing the result as an array or object of the evaluated values.\n\nWhen given an array, map always returns an array.\n\n```yaml\ntemplate:\n  $map: [2, 4, 6]\n  each(x): {$eval: 'x + a'}\ncontext:  {a: 1}\nresult:   [3, 5, 7]\n---\ntemplate:\n  $map: [2, 4, 6]\n  each(x,i): {$eval: 'x + a + i'}\ncontext:  {a: 1}\nresult:   [3, 6, 9]\n```\nThe array or object is the value of the `$map` property, and the expression to evaluate\nis given by `each(var[,key|index])` where `var` is the name of the variable containing each\nelement and `key|index` is either the object key or array index of the value. In the case of \niterating over an object and no `key|index` var name is given, `var` will be an object with \ntwo keys: `key` and `val`. These keys correspond to a key in the object and its corresponding value.\n\nWhen $map is given an object, the expression defined by `each(var)` must evaluate to an\nobject for each key/value pair (`key` and `val`). The objects constructed by each 'each(var)'\ncan then be merged internally to give the resulting object with later keys overwriting \nthe previous ones. Otherwise the expression becomes invalid for the $map operator.\n\n```yaml\ntemplate:\n  $map: {a: 1, b: 2, c: 3}\n  each(y): {'${y.key}x': {$eval: 'y.val + 1'}}\ncontext:  {}\nresult: {ax: 2, bx: 3, cx: 4}\n---\ntemplate:\n  $map: {a: 1, b: 2, c: 3}\n  each(v,k): {'${k}x': {$eval: 'v + 1'}}\ncontext:  {}\nresult: {ax: 2, bx: 3, cx: 4}\n```\n\n### `$match`\n\nThe `$match` operator is not dissimilar to pattern matching operators.\nIt gets an object, in which every key is a string expression(s) to\nevaluate to `true` or `false` based on the context. The result will\nbe an array of things (all types are supported) that were values\ncorresponding to the keys that were evaluated to `true`. The order of\nthe things in the array will be arbitrary. If there are no matches,\nthe result is an empty array.\n\n```yaml\ntemplate: {$match: {\"x == 10\": \"ten\", \"x == 20\": \"twenty\"}}\ncontext: {x: 10}\nresult: [\"ten\"]\n```\n\n```yaml\ntemplate: {$match: {\"x == 10 || x == 20\": \"tens\", \"x == 10\": \"ten\"}}\ncontext: {x: 10}\none possible result: [\"tens\", \"ten\"]\nanother possible result: [\"ten\", \"tens\"]\n```\n```yaml\ntemplate: {$match: {\"x < 10\": \"tens\"}}\ncontext: {x: 10}\nresult: []\n```\n\n### `$switch`\n\nThe `$switch` operator behaves like a combination of the `$if` and\n`$match` operator for more complex boolean logic. It gets an object,\nin which every key is a string expression(s), where at most *one* must\nevaluate to `true` and the remaining to `false` based on the context.\nThe result will be the value corresponding to the key that were\nevaluated to `true`.\n\nIf there are no matches, the result is either null or if used within an\nobject or array, omitted from the parent object.\n\n```yaml\ntemplate: {$switch: {\"x == 10\": \"ten\", \"x == 20\": \"twenty\"}}\ncontext: {x: 10}\nresult: \"ten\"\n```\n\n```yaml\ntemplate: {$switch: {\"x < 10\": 1}}\ncontext: {x: 10}\nresult: null\n```\n\n```yaml\ntemplate: {a: 1, b: {$switch: {\"x == 10 || x == 20\": 2, \"x > 20\": 3}}}\ncontext: {x: 10}\nresult: {a: 1, b: 2}\n```\n\n```yaml\ntemplate: {a: 1, b: {$switch: {\"x == 1\": 2, \"x == 3\": 3}}}\ncontext: {x: 2}\nresult: {a: 1}\n```\n\n```yaml\ntemplate: [1, b: {$switch: {\"x == 1\": 2, \"x == 10\": 3}}]\ncontext: {x: 2}\nresult: [1, 2]\n```\n\n```yaml\ncontext:  {cond: 3}\ntemplate: [0, {$switch: {'cond > 3': 2, 'cond == 5': 3}}]\nresult:   [0]\n```\n\n### `$merge`\n\nThe `$merge` operator merges an array of objects, returning a single object\nthat combines all of the objects in the array, where the right-side objects\noverwrite the values of the left-side ones.\n\n```yaml\ntemplate: {$merge: [{a: 1, b: 1}, {b: 2, c: 3}, {d: 4}]}\ncontext:  {}\nresult:   {a: 1, b: 2, c: 3, d: 4}\n```\n\n### `$mergeDeep`\n\nThe `$mergeDeep` operator is like `$merge`, but it recurses into objects to\ncombine their contents property by property.  Arrays are concatenated.\n\n```yaml\ntemplate:\n  $mergeDeep:\n    - task:\n        payload:\n          command: [a, b]\n    - task:\n        extra:\n          foo: bar\n    - task:\n        payload:\n          command: [c]\ncontext:  {}\nresult:\n  task:\n    extra:\n      foo: bar\n    payload:\n      command: [a, b, c]\n```\n\n### `$sort`\n\nThe `$sort` operator sorts the given array. It takes a `by(var)` property which\nshould evaluate to a comparable value for each element. The `by(var)` property\ndefaults to the identity function.\n\n```yaml\ntemplate:\n  $sort: [{a: 2}, {a: 1, b: []}, {a: 3}]\n  by(x): 'x.a'\ncontext:  {}\nresult:   [{a: 1, b: []}, {a: 2}, {a: 3}]\n```\n\n### `$reverse`\n\nThe `$reverse` operator simply reverses the given array.\n\n```yaml\ntemplate: {$reverse: [3, 4, 1, 2]}\ncontext:  {}\nresult:   [2, 1, 4, 3]\n```\n\n### Escaping operators\n\nAll property names starting with `$` are reserved for JSON-e.\nYou can use `$$` to escape such properties:\n\n```yaml\ntemplate: {$$reverse: [3, 2, {$$eval: '2 - 1'}, 0]}\ncontext:  {}\nresult:   {$reverse: [3, 2, {$eval: '2 - 1'}, 0]}\n```\n\n## Truthiness\n\nMany values can be evaluated in context where booleans are required,\nnot just booleans themselves. JSON-e defines the following values as false.\nAnything else will be true.\n\n```yaml\ntemplate: {$if: 'a || b || c || d || e || f', then: \"uh oh\", else: \"falsy\" }\ncontext: {a: null, b: [], c: {}, d: \"\", e: 0, f: false}\nresult: \"falsy\"\n```\n\n## Expression Syntax\n\nExpression are given in a simple Python- or JavaScript-like expression\nlanguage. Its data types are limited to JSON types plus function objects.\n\n### Literals\n\nLiterals are similar to those for JSON. Numeric literals only accept integer\nand decimal notation. Strings do not support any kind of escaping. The use of\n`\\n` and `\\t` in the example below depends on the YAML parser to expand the\nescapes.\n\n```yaml\ntemplate:\n  - {$eval: \"1.3\"}\n  - {$eval: \"'abc'\"}\n  - {$eval: '\"abc\"'}\n  - {$eval: \"'\\n\\t'\"}\ncontext: {}\nresult:\n  - 1.3\n  - \"abc\"\n  - \"abc\"\n  - \"\\n\\t\"\n```\n\nArray and object literals also look much like JSON, with bare identifiers\nallowed as keys like in Javascript:\n\n```yaml\ntemplate:\n  - {$eval: '[1, 2, \"three\"]'}\n  - {$eval: '{foo: 1, \"bar\": 2}'}\ncontext: {}\nresult:\n  - [1, 2, \"three\"]\n  - {\"foo\": 1, \"bar\": 2}\n```\n\n### Context References\n\nBare identifiers refer to items from the context or to built-ins (described below).\n\n```yaml\ntemplate: {$eval: '[x, z, x+z]'}\ncontext: {x: 'quick', z: 'sort'}\nresult: ['quick', 'sort', 'quicksort']\n```\n\n### Arithmetic Operations\n\nThe usual arithmetic operators are all defined, with typical associativity and\nprecedence:\n\n```yaml\ntemplate:\n  - {$eval: 'x + z'}\n  - {$eval: 's + t'}\n  - {$eval: 'z - x'}\n  - {$eval: 'x * z'}\n  - {$eval: 'z / x'}\n  - {$eval: 'z ** 2'}\n  - {$eval: '(z / x) ** 2'}\ncontext: {x: 10, z: 20, s: \"face\", t: \"plant\"}\nresult:\n  - 30\n  - \"faceplant\"\n  - 10\n  - 200\n  - 2\n  - 400\n  - 4\n```\n\nNote that strings can be concatenated with `+`, but none of the other operators\napply.\n\n### Comparison Operations\n\nComparisons work as expected.  Equality is \"deep\" in the sense of doing\ncomparisons of the contents of data structures.\n\n```yaml\ntemplate:\n  - {$eval: 'x < z'}\n  - {$eval: 'x <= z'}\n  - {$eval: 'x > z'}\n  - {$eval: 'x >= z'}\n  - {$eval: 'deep == [1, [3, {a: 5}]]'}\n  - {$eval: 'deep != [1, [3, {a: 5}]]'}\ncontext: {x: -10, z: 10, deep: [1, [3, {a: 5}]]}\nresult: [true, true, false, false, true, false]\n```\n\n### Boolean Operations\n\nBoolean operations use C- and Javascript-style symbols `||`, `&&`, and `!`:\n\n```yaml\ntemplate: {$eval: '!(false || false) && true'}\ncontext: {}\nresult: true\n```\n\nJson-e supports short-circuit evaluation, so if in `||` left operand is true \nreturning value will be true no matter what right operand is:\n\n```yaml\ncontext: {}\ntemplate: {$eval: \"true || b\"}\nresult: true\n```\n\nAnd if in `&&` left operand is false returning value will be false no matter \nwhat right operand is:\n\n```yaml\ncontext: {}\ntemplate: {$eval: \"false && b\"}\nresult: false\n```\n\n### Object Property Access\n\nLike Javascript, object properties can be accessed either with array-index\nsyntax or with dot syntax. Unlike Javascript, `obj.prop` is an error if `obj`\ndoes not have `prop`, while `obj['prop']` will evaluate to `null`.\n\n```yaml\ntemplate: {$eval: 'v.a + v[\"b\"]'}\ncontext: {v: {a: 'apple', b: 'bananna', c: 'carrot'}}\nresult: 'applebananna'\n````\n\n### Indexing and Slicing\n\nStrings and arrays can be indexed and sliced using a Python-like indexing\nscheme.  Negative indexes are counted from the end of the value.  Slices are\ntreated as \"half-open\", meaning that the result contains the first index and\ndoes not contain the second index.  A \"backward\" slice with the start index\ngreater than the end index is treated as empty.\n\n```yaml\ntemplate:\n  - {$eval: '[array[1], string[1]]'}\n  - {$eval: '[array[1:4], string[1:4]]'}\n  - {$eval: '[array[2:], string[2:]]'}\n  - {$eval: '[array[:2], string[:2]]'}\n  - {$eval: '[array[4:2], string[4:2]]'}\n  - {$eval: '[array[-2], string[-2]]'}\n  - {$eval: '[array[-2:], string[-2:]]'}\n  - {$eval: '[array[:-3], string[:-3]]'}\ncontext: {array: ['a', 'b', 'c', 'd', 'e'], string: 'abcde'}\nresult:\n  - ['b', 'b']\n  - [['b', 'c', 'd'], 'bcd']\n  - [['c', 'd', 'e'], 'cde']\n  - [['a', 'b'], 'ab']\n  - [[], '']\n  - ['d', 'd']\n  - [['d', 'e'], 'de']\n  - [['a', 'b'], 'ab']\n```\n\n### Containment Operation\n\nThe `in` keyword can be used to check for containment: a property in an object,\nan element in an array, or a substring in a string.\n\n```yaml\ntemplate:\n  - {$eval: '\"foo\" in {foo: 1, bar: 2}'}\n  - {$eval: '\"foo\" in [\"foo\", \"bar\"]'}\n  - {$eval: '\"foo\" in \"foobar\"'}\ncontext: {}\nresult: [true, true, true]\n```\n\n### Function Invocation\n\nFunction calls are made with the usual `fn(arg1, arg2)` syntax. Functions are\nnot JSON data, so they cannot be created in JSON-e, but they can be provided as\nbuilt-ins or supplied in the context and called from JSON-e.\n\n### Built-In Functions and Variables\n\nThe expression language provides a laundry-list of built-in functions/variables. Library\nusers can easily add additional functions/variables, or override the built-ins, as part\nof the context.\n\n#### Time\n\nThe built-in context value `now` is set to the current time at the start of\nevaluation of the template, and used as the default \"from\" value for `$fromNow`\nand the built-in `fromNow()`.\n\n```yaml\ntemplate:\n  - {$eval: 'now'}\n  - {$eval: 'fromNow(\"1 minute\")'}\n  - {$eval: 'fromNow(\"1 minute\", \"2017-01-19T16:27:20.974Z\")'}\ncontext: {}\nresult:\n  - '2017-01-19T16:27:20.974Z',\n  - '2017-01-19T16:28:20.974Z',\n  - '2017-01-19T16:28:20.974Z',\n```\n\n#### Math\n\n```yaml\ntemplate:\n  # the smallest of the arguments\n  - {$eval: 'min(1, 3, 5)'}\n  # the largest of the arguments\n  - {$eval: 'max(2, 4, 6)'}\n  # mathematical functions\n  - {$eval: 'sqrt(16)'}\n  - {$eval: 'ceil(0.3)'}\n  - {$eval: 'floor(0.3)'}\n  - {$eval: 'abs(-0.3)'}\ncontext: {}\nresult:\n  - 1\n  - 6\n  - 4\n  - 1\n  - 0\n  - 0.3\n```\n\n#### Strings\n\n```yaml\ntemplate:\n  # convert string case\n  - {$eval: 'lowercase(\"Fools!\")'}\n  - {$eval: 'uppercase(\"Fools!\")'}\n  # convert string, number, boolean, or array to string\n  - {$eval: 'str(130)'}\n  # strip whitespace from left, right, or both ends of a string\n  - {$eval: 'lstrip(\"  room  \")'}\n  - {$eval: 'rstrip(\"  room  \")'}\n  - {$eval: 'strip(\"  room  \")'}\n  - {$eval: 'split(\"left:right\", \":\")'}\ncontext: {}\nresult:\n  - \"fools!\"\n  - \"FOOLS!\"\n  - \"130\"\n  - \"room  \"\n  - \"  room\"\n  - room\n  - [left, right]\n```\n\n#### Arrays\n\n```yaml\ntemplate:\n  # Joins arrays of strings and numbers (including mixed types) into a string using a separator, \n  # which can also be either string or number.\n  - {$eval: 'join([\"carpe\", \"diem\"], \" \")'}\n  - {$eval: 'join([1, 3], 2)'}\ncontext: {}\nresult:\n  - carpe diem\n  - \"123\"\n```\n\n#### Context\n\nThe `defined(varname)` built-in determines if the named variable is defined in the current context.\nThe current context includes any variables defined or redefined by `$let` or similar operators.\nNote that the name must be given as a string.\n\n```yaml\ntemplate: {$if: 'defined(\"x\")', then: {$eval: 'x'}, else: 20}\ncontext: {y: 10}\nresult: 20\n```\n\n#### Type\n\nThe `typeof()` built-in returns the type of an object. Its behavior around\n`null` is reminiscent of JavaScript.\n\n```yaml\ntemplate:\n - \"${typeof('abc')}\"\n - \"${typeof(42)}\"\n - \"${typeof(42.0)}\"\n - \"${typeof(true)}\"\n - \"${typeof([])}\"\n - \"${typeof({})}\"\n - \"${typeof(typeof)}\"\n - {$eval: \"typeof(null)\"}\n - \"${typeof(null)}\"\ncontext: {}\nresult:\n - string\n - number\n - number\n - boolean\n - array\n - object\n - function\n - null \n - ''    # .. which interpolates to an empty string\n```\n\n#### Length\n\nThe `len()` built-in returns the length of a string or array.\n\n```yaml\ntemplate: {$eval: 'len([1, 2, 3])'}\ncontext: {}\nresult: 3\n```\n");class I extends a.a.Component{static hashChanged(){const e=window.location.hash.split("/")[1];if(e){const t=document.getElementById(e);t&&t.scrollIntoView()}}componentWillMount(){window.addEventListener("hashchange",()=>I.hashChanged()),I.hashChanged()}render(){const e=[{name:"About",section:z.child("JSON-e")},{name:"Playground"},{name:"Interface",section:z.child("Interface")},{name:"Language",section:z.child("Language Reference"),showDemo:!0}];return a.a.createElement("div",{className:"wrap"},a.a.createElement("div",{className:"main"},a.a.createElement("aside",{className:"sidebar"},a.a.createElement(o.b,{f:3},"JSON-e v",i.version),a.a.createElement(o.d,null,"A data-structure parameterization system for embedding context in JSON objects"),a.a.createElement("hr",null),a.a.createElement("ul",null,e.map(({name:e,section:t})=>a.a.createElement(x,{key:e,title:e,tab:e,section:t}))),a.a.createElement("hr",null),a.a.createElement("div",null,a.a.createElement(o.d,{f:1},"Brought to you by the Mozillians behind"," ",a.a.createElement("a",{href:"https://docs.taskcluster.net/"},"Taskcluster"),"."))),a.a.createElement("div",{className:"content"},e.map(({name:e,section:t,showDemo:n})=>"Playground"===e?a.a.createElement(A,{key:e}):a.a.createElement(v,{section:t,showDemo:Boolean(n),key:e})))))}}var J=I;Object(s.render)(a.a.createElement(J,null),document.getElementById("root"))},28:function(e,t){let n={isString:e=>"string"==typeof e,isNumber:e=>"number"==typeof e,isInteger:e=>"number"==typeof e&&Number.isInteger(e),isBool:e=>"boolean"==typeof e,isNull:e=>null===e,isArray:e=>e instanceof Array,isObject:e=>e instanceof Object&&!(e instanceof Array)&&!(e instanceof Function),isFunction:e=>e instanceof Function,isJSON:e=>{if(n.isString(e)||n.isNumber(e)||n.isBool(e)||null===e)return!0;if(n.isArray(e))return e.every(e=>n.isJSON(e));let t=!0;if(n.isobject(e)){for(let r of Object.keys(e))if(e.hasOwnProperty(r)&&(t=t&&n.isJSON(e[r]),!t))break;return t}return!1},isTruthy:e=>null!==e&&(n.isArray(e)&&e.length>0||n.isObject(e)&&Object.keys(e).length>0||n.isString(e)&&e.length>0||n.isNumber(e)&&0!==e||n.isBool(e)&&e||n.isFunction(e))};e.exports=n},45:function(e,t){var n=new RegExp(["^(\\s*(-|\\+))?","(\\s*(\\d+)\\s*y((ears?)|r)?)?","(\\s*(\\d+)\\s*mo(nths?)?)?","(\\s*(\\d+)\\s*w((eeks?)|k)?)?","(\\s*(\\d+)\\s*d(ays?)?)?","(\\s*(\\d+)\\s*h((ours?)|r)?)?","(\\s*(\\d+)\\s*m(in(utes?)?)?)?","(\\s*(\\d+)\\s*s(ec(onds?)?)?)?","\\s*$"].join(""),"i");e.exports=(e="",t)=>{let r=function(e){var t=n.exec(e||"");if(!t)throw new Error("String: '"+e+"' isn't a time expression");var r="-"===t[2]?-1:1;return{years:parseInt(t[4]||0,10)*r,months:parseInt(t[8]||0,10)*r,weeks:parseInt(t[11]||0,10)*r,days:parseInt(t[15]||0,10)*r,hours:parseInt(t[18]||0,10)*r,minutes:parseInt(t[22]||0,10)*r,seconds:parseInt(t[25]||0,10)*r}}(e);return r.days+=30*r.months,r.days+=365*r.years,t=t?new Date(t):new Date,new Date(t.getTime()+7*r.weeks*24*60*60*1e3+24*r.days*60*60*1e3+60*r.hours*60*1e3+60*r.minutes*1e3+1e3*r.seconds).toJSON()}},48:function(e){e.exports=JSON.parse('{"name":"json-e","version":"4.3.0","description":"json parameterization module inspired from json-parameterization","main":"./src/index.js","types":"./src/index.d.ts","scripts":{"lint":"eslint src/*.js test/*.js","test":"yarn lint && mocha test/*_test.js","build-demo":"cd demo && yarn && yarn build","start-demo":"cd demo && yarn && yarn start"},"files":["src"],"repository":{"type":"git","url":"https://github.com/taskcluster/json-e"},"author":"","license":"MPL-2.0","dependencies":{"json-stable-stringify-without-jsonify":"^1.0.1"},"devDependencies":{"assume":"^2.0.0","browserify":"^14.5.0","eslint":"^5.12.1","mocha":"^4.0.1","source-map-support":"^0.5.0","timekeeper":"^2.0.0"},"engines":{"node":">=6.4.0"},"renovate":{"extends":["config:base",":preserveSemverRanges",":rebaseStalePrs"]}}')},52:function(e,t,n){const{Parser:r}=n(183),a=n(185),{Interpreter:s}=n(186);var o=n(45),i=n(187),{isString:l,isNumber:c,isBool:u,isArray:h,isObject:p,isTruthy:m}=n(28),d=n(188),{JSONTemplateError:f,TemplateError:g}=n(15);let y=e=>new SyntaxError(`Found ${e.value}, expected !=, &&, (, *, **, +, -, ., /, <, <=, ==, >, >=, [, in, ||`);function b(e,t){var n="",r=new RegExp(t.join("|")+"$");for(var a of Object.keys(e).sort())r.test(a)||(n+=" "+a);if(n)throw new g(t[0].replace("\\","")+" has undefined properties:"+n)}let v=e=>Array.isArray(e)?[].concat(...e.map(v)):e,w=(e,t)=>{let n,r="",a=e;for(;-1!==(n=a.search(/\$?\${/g));)if(r+=a.slice(0,n),"$"!=a[n+1]){let e=O(a.slice(n+2),"}",t);if(h(e.result)||p(e.result)){let t=a.slice(n+2,n+e.offset);throw new g(`interpolation of '${t}' produced an array or object`)}null===e.result?r+="":r+=e.result.toString(),a=a.slice(n+e.offset+1)}else r+="${",a=a.slice(n+3);return r+=a,r},x={},$={$eval:(e,t)=>{if(b(e,["\\$eval"]),!l(e.$eval))throw new g("$eval must be given a string expression");return T(e.$eval,t)},$flatten:(e,t)=>{b(e,["\\$flatten"]);let n=k(e.$flatten,t);if(!h(n))throw new g("$flatten value must evaluate to an array");return n.reduce((e,t)=>e.concat(t),[])},$flattenDeep:(e,t)=>{b(e,["\\$flattenDeep"]);let n=k(e.$flattenDeep,t);if(!h(n))throw new g("$flattenDeep value must evaluate to an array");return v(n)},$fromNow:(e,t)=>{b(e,["\\$fromNow","from"]);let n=k(e.$fromNow,t),r=t.now;if(e.from&&(r=k(e.from,t)),!l(n))throw new g("$fromNow expects a string");return o(n,r)},$if:(e,t)=>{if(b(e,["\\$if","then","else"]),!l(e.$if))throw new g("$if can evaluate string expressions only");if(m(T(e.$if,t))){if(e.hasOwnProperty("$then"))throw new g("$if Syntax error: $then: should be spelled then: (no $)");return e.hasOwnProperty("then")?k(e.then,t):x}return e.hasOwnProperty("else")?k(e.else,t):x},$json:(e,t)=>(b(e,["\\$json"]),i(k(e.$json,t))),$let:(e,t)=>{if(b(e,["\\$let","in"]),!p(e.$let))throw new g("$let value must be an object");let n={},r=k(e.$let,t);if(!p(r))throw new g("$let value must be an object");Object.keys(r).forEach(e=>{if(!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(e))throw new g("top level keys of $let must follow /[a-zA-Z_][a-zA-Z0-9_]*/");n[e]=r[e]});var a=Object.assign(t,n);if(null==e.in)throw new g("$let operator requires an `in` clause");return k(e.in,a)},$map:(e,t)=>{b(e,["\\$map","each\\(([a-zA-Z_][a-zA-Z0-9_]*)(,\\s*([a-zA-Z_][a-zA-Z0-9_]*))?\\)"]);let n=k(e.$map,t);if(!h(n)&&!p(n))throw new g("$map value must evaluate to an array or object");if(2!==Object.keys(e).length)throw new g("$map must have exactly two properties");let r=Object.keys(e).filter(e=>"$map"!==e)[0],a=/^each\(([a-zA-Z_][a-zA-Z0-9_]*)(,\s*([a-zA-Z_][a-zA-Z0-9_]*))?\)$/.exec(r);if(!a)throw new g("$map requires each(identifier) syntax");let s=a[1],o=a[3],i=e[r];if(p(n)){let e;return n=Object.keys(n).map(e=>({key:e,val:n[e]})),n=n.map(n=>{let r=void 0!==o?{[s]:n.val,[o]:n.key}:{[s]:n};if(e=k(i,Object.assign({},t,r)),!p(e))throw new g(`$map on objects expects each(${s}) to evaluate to an object`);return e}).filter(e=>e!==x),Object.assign({},...n)}return n.map((e,n)=>{let r=void 0!==o?{[s]:e,[o]:n}:{[s]:e};return k(i,Object.assign({},t,r))}).filter(e=>e!==x)},$match:(e,t)=>{if(b(e,["\\$match"]),!p(e.$match))throw new g("$match can evaluate objects only");const n=[],r=e.$match;for(let e of Object.keys(r).sort())m(T(e,t))&&n.push(k(r[e],t));return n},$switch:(e,t)=>{if(b(e,["\\$switch"]),!p(e.$switch))throw new g("$switch can evaluate objects only");let n=[];const r=e.$switch;for(let e of Object.keys(r))m(T(e,t))&&n.push(k(r[e],t));if(n.length>1)throw new g("$switch can only have one truthy condition");return n.length>0?n[0]:x},$merge:(e,t)=>{b(e,["\\$merge"]);let n=k(e.$merge,t);if(!h(n)||n.some(e=>!p(e)))throw new g("$merge value must evaluate to an array of objects");return Object.assign({},...n)},$mergeDeep:(e,t)=>{b(e,["\\$mergeDeep"]);let n=k(e.$mergeDeep,t);if(!h(n)||n.some(e=>!p(e)))throw new g("$mergeDeep value must evaluate to an array of objects");if(0===n.length)return{};let r=(e,t)=>{if(h(e)&&h(t))return e.concat(t);if(p(e)&&p(t)){let n=Object.assign({},e);for(let a in t)n[a]=a in e?r(e[a],t[a]):t[a];return n}return t};return n.reduce(r,n.shift())},$reverse:(e,t)=>{b(e,["\\$reverse"]);let n=k(e.$reverse,t);if(!h(n))throw new g("$reverse value must evaluate to an array of objects");return n.reverse()},$sort:(e,t)=>{b(e,["\\$sort","by\\(([a-zA-Z_][a-zA-Z0-9_]*)\\)"]);let n=k(e.$sort,t);if(!h(n))throw new g("$sorted values to be sorted must have the same type");let r,a=Object.keys(e).filter(e=>"$sort"!==e)[0],s=/^by\(([a-zA-Z_][a-zA-Z0-9_]*)\)$/.exec(a);if(s){let n=Object.assign({},t),o=s[1],i=e[a];r=e=>(n[o]=e,T(i,n))}else{if(n.some(e=>h(e)||p(e)))throw new g("$sorted values to be sorted must have the same type");r=e=>e}let o=n.map(e=>[r(e),e]);if(o.length>0){let e=typeof o[0][0];if("number"!==e&&"string"!==e||o.some(t=>e!==typeof t[0]))throw new g("$sorted values to be sorted must have the same type")}return o.sort((e,t)=>(e=e[0])<(t=t[0])?-1:e>t?1:0).map(e=>e[1])}},k=(e,t)=>{if(c(e)||u(e)||null===e)return e;if(l(e))return w(e,t);if(h(e))return e.map((e,n)=>{try{return k(e,t)}catch(e){throw e instanceof f&&e.add_location(`[${n}]`),e}}).filter(e=>e!==x);let n=Object.keys($).filter(t=>e.hasOwnProperty(t));if(n.length>1)throw new g("only one operator allowed");if(1===n.length)return $[n[0]](e,t);let r={};for(let n of Object.keys(e)){let a;try{a=k(e[n],t)}catch(e){throw e instanceof f&&(/^[a-zA-Z][a-zA-Z0-9]*$/.test(n)?e.add_location("."+n):e.add_location(`[${JSON.stringify(n)}]`)),e}if(a!==x){if(n.startsWith("$$"))n=n.substr(1);else{if(/^\$[a-zA-Z][a-zA-Z0-9]*$/.test(n))throw new g("$<identifier> is reserved; use $$<identifier>");n=w(n,t)}r[n]=a}}return r},j=new a({ignore:"\\s+",patterns:{number:"[0-9]+(?:\\.[0-9]+)?",identifier:"[a-zA-Z_][a-zA-Z_0-9]*",string:"'[^']*'|\"[^\"]*\"",true:"true(?![a-zA-Z_0-9])",false:"false(?![a-zA-Z_0-9])",in:"in(?![a-zA-Z_0-9])",null:"null(?![a-zA-Z_0-9])"},tokens:["**",..."+-*/[].(){}:,".split(""),">=","<=","<",">","==","!=","!","&&","||","true","false","in","null","number","identifier","string"]}),T=(e,t)=>{let n=new r(j,e),a=n.parse();if(null!=n.current_token)throw y(n.current_token);return new s(t).interpret(a)},O=(e,t,n)=>{let a=new r(j,e),o=a.parse(),i=a.current_token;if(!i){let n=e.length;throw new SyntaxError("Found end of string, expected "+t,{start:n,end:n})}if(i.kind!==t)throw y(i);return{result:new s(n).interpret(o),offset:i.start+2}};e.exports=(e,t={})=>{if(!Object.keys(t).every(e=>/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(e)))throw new g("top level keys of context must follow /[a-zA-Z_][a-zA-Z0-9_]*/");t=d(Object.assign({},{now:o("0 seconds")},t));let n=k(e,t);return n===x?null:n}},53:function(e,t,n){e.exports=n(190)}},[[53,1,2]]]);